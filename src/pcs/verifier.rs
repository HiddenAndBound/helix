//! BaseFold Verifier Implementation
//!
//! This module contains the verifier-side logic for the BaseFold polynomial commitment scheme,
//! including proof verification and all verifier helper functions.

use crate::pcs::utils::{fold_pair, hash_field_pair};
use crate::{
    Fp, Fp4,
    challenger::Challenger,
    merkle_tree::{MerklePath, MerkleTree},
    helix::univariate::UnivariatePoly,
};
use anyhow::bail;
use blake3::Hasher;
use itertools::multizip;
use p3_field::{ExtensionField, Field};
use p3_field::{PrimeCharacteristicRing, RawDataSerializable};

use super::{BaseFoldConfig, Basefold, BasefoldCommitment, EvalProof};

impl Basefold {
    /// Verifies an evaluation proof, checking that a committed polynomial evaluates to the claimed value.
    ///
    /// This is the verification phase of the BaseFold protocol, where the verifier checks the prover's
    /// claim that P(r) = v without access to the polynomial P itself, using only the commitment and proof.
    ///
    /// # Verification Process
    /// The verifier performs two main checks:
    ///
    /// ## 1. Sum-Check Verification (Commit Phase)
    /// For each round i:
    /// - Check sum-check consistency: g_i(0) + g_i(1) = current_claim
    /// - Generate challenge r_i from g_i coefficients via Fiat-Shamir
    /// - Update claim: claim_{i+1} = g_i(r_i)
    /// - Observe folded encoding commitment
    ///
    /// ## 2. Query Verification (Query Phase)
    /// For QUERIES random positions:
    /// - Verify Merkle paths authenticate queried codewords
    /// - Check folding consistency: folded_codewords match next round's codewords
    /// - Ensure final folded codeword equals final claim
    ///
    /// # Parameters
    /// * `proof` - The evaluation proof generated by the prover
    /// * `evaluation` - Claimed value v = P(r) to verify
    /// * `eval_point` - Evaluation point r = [r₁, r₂, ..., rₙ]
    /// * `commitment` - The polynomial commitment to verify against
    /// * `roots` - FFT roots used in folding (must match prover's roots)
    /// * `challenger` - Fiat-Shamir challenger (must be in same state as prover's)
    ///
    /// # Returns
    /// * `Ok(())` - If proof is valid and evaluation claim is accepted
    /// * `Err(anyhow::Error)` - If any verification check fails:
    ///   - Sum-check consistency violation
    ///   - Merkle path verification failure
    ///   - Folding consistency check failure
    ///   - Final claim mismatch
    ///
    /// # Mathematical Guarantees
    /// * **Completeness**: Honest proofs with correct evaluations always verify
    /// * **Soundness**: Invalid proofs are rejected except with probability ≈ QUERIES/|Fp4|
    /// * **Efficiency**: Verification time is O(log(poly_size) * QUERIES + rounds)
    ///
    /// # Security Analysis
    /// The verification provides soundness against:
    /// - **Encoding attacks**: Reed-Solomon distance detects corrupted encodings
    /// - **Sum-check attacks**: Interactive protocol ensures evaluation correctness
    /// - **Folding attacks**: Query consistency checks detect invalid folding operations
    ///
    /// With QUERIES = 144 and |Fp4| ≈ 2¹²⁴, soundness error is approximately 2⁻¹⁰⁰.
    ///
    /// # Example
    /// ```rust,ignore
    /// let mut verifier_challenger = Challenger::new();
    /// let config = BaseFoldConfig::default();
    /// match Basefold::verify(proof, evaluation, &eval_point, commitment,
    ///                       &roots, &mut verifier_challenger, &config) {
    ///     Ok(()) => println!("Proof verified successfully"),
    ///     Err(e) => println!("Verification failed: {}", e),
    /// }
    /// ```
    pub fn verify(
        proof: EvalProof,
        evaluation: Fp4,
        eval_point: &[Fp4],
        commitment: BasefoldCommitment,
        roots: &[Vec<Fp>],
        challenger: &mut Challenger,
        config: &BaseFoldConfig,
    ) -> anyhow::Result<()> {
        // TODO: Observe statement (eval, eval_point, commitment)
        let mut current_claim = evaluation;

        let rounds = eval_point.len();

        let mut random_point = Vec::new();
        //Commit phase
        for round in 0..rounds {
            let round_poly = &proof.sum_check_rounds[round];
            verify_sum_check_round(round_poly, &mut current_claim, &eval_point, round)?;

            challenger.observe_fp4_elems(&round_poly.coefficients());
            let r = challenger.get_challenge();
            current_claim = round_poly.evaluate(r);
            random_point.push(r);
            challenger.observe_commitment(&proof.commitments[round]);
        }

        //Query Phase

        // The queries are always in the range 0..encoding.len()/2
        let log_query_range = (rounds as u32) + config.rate.trailing_zeros() - 1;
        let mut query_range = 1 << log_query_range;
        let mut queries = challenger.get_indices(log_query_range, config.queries);
        let mut folded_codewords = vec![Fp4::ZERO; config.queries];

        for round in 0..rounds {
            let halfsize = query_range >> 1;
            let oracle_commitment = match round {
                0 => commitment.commitment,
                _ => proof.commitments[round - 1],
            };

            let (codewords, paths) = (&proof.codewords[round], &proof.paths[round]);

            check_query_consistency(
                &mut queries,
                &folded_codewords,
                &codewords,
                query_range,
                round,
            )?;

            verify_paths(codewords, paths, &queries, oracle_commitment)?;

            fold_codewords(
                &mut folded_codewords,
                codewords,
                &queries,
                random_point[round],
                &roots[round],
            );

            query_range = halfsize;
        }

        if folded_codewords[0] != current_claim {
            anyhow::bail!(
                "Final claim verification failed: {:?} != {:?}",
                folded_codewords[0],
                current_claim
            );
        }
        Ok(())
    }
}

/// Folds queried codeword pairs using the current round's challenge.
///
/// This operation mimics the encoding folding performed by the prover,
/// allowing the verifier to check consistency across folding rounds.
pub fn fold_codewords(
    folded_codewords: &mut [Fp4],
    codewords: &[(Fp4, Fp4)],
    queries: &[usize],
    r: Fp4,
    roots: &[Fp],
) {
    for (query, fold, &codeword_pair) in multizip((queries, folded_codewords, codewords)) {
        *fold = fold_pair(codeword_pair, r, roots[*query].inverse());
    }
}

/// Folds queried codeword pairs using the current round's challenge.
///
/// This operation mimics the encoding folding performed by the prover,
/// allowing the verifier to check consistency across folding rounds.
pub fn fold_codewords_vec<F>(
    folded_codewords: &mut [Fp4],
    codewords: &[Vec<F>],
    queries: &[usize],
    r: Fp4,
    roots: &[Fp],
) where
    F: ExtensionField<Fp>,
    Fp4: ExtensionField<F>,
{
    for (query, fold, codeword_pair) in multizip((queries, folded_codewords, codewords)) {
        *fold = fold_pair(
            (codeword_pair[0], codeword_pair[1]),
            r,
            roots[*query].inverse(),
        );
    }
}

pub fn fold_codewords_vec_skip<F>(
    folded_codewords: &mut [Fp4],
    codewords: &[Vec<F>],
    queries: &[usize],
    r: Fp4,
    roots: &[Fp],
) where
    F: ExtensionField<Fp>,
    Fp4: ExtensionField<F>,
{
    for (query, fold, codeword_pair) in multizip((queries, folded_codewords, codewords)) {
        *fold = fold_pair(
            (codeword_pair[0], codeword_pair[1]),
            r,
            roots[*query].inverse(),
        );
    }
}

/// Verifies Merkle authentication paths for all queried codeword pairs.
///
/// Ensures that the prover provided authentic codewords from the committed
/// Reed-Solomon encoding, preventing substitution attacks.
pub fn verify_paths(
    codewords: &[(Fp4, Fp4)],
    paths: &[MerklePath],
    queries: &[usize],
    oracle_commitment: [u8; 32],
) -> anyhow::Result<()> {
    for (query, path, &codeword_pair) in multizip((queries, paths, codewords)) {
        let (left, right) = codeword_pair;
        let leaf_hash = hash_field_pair(left, right);
        MerkleTree::verify_path(leaf_hash, *query, path, oracle_commitment)?;
    }
    Ok(())
}

/// Verifies consistency between folded codewords across rounds.
///
/// Checks that the current round's codeword pairs correctly fold to match
/// the previous round's folded results, preventing encoding manipulation.
pub fn check_query_consistency(
    queries: &mut [usize],
    folded_codewords: &[Fp4],
    codewords: &[(Fp4, Fp4)],
    query_range: usize,
    round: usize,
) -> anyhow::Result<()> {
    // Skip consistency check for first round (no previous folded codewords exist)
    if round > 0 {
        for (query, &folded_codeword, &codeword_pair) in
            multizip((queries, folded_codewords, codewords))
        {
            let (left, right) = codeword_pair;
            check_fold(folded_codeword, *query, query_range, left, right)?;
            update_query(query, query_range);
        }
    }
    Ok(())
}

/// Verifies consistency between folded codewords across rounds.
///
/// Checks that the current round's codeword pairs correctly fold to match
/// the previous round's folded results, preventing encoding manipulation.
pub fn check_query_consistency_vec(
    queries: &mut [usize],
    folded_codewords: &[Fp4],
    codewords: &[Vec<Fp4>],
    query_range: usize,
    round: usize,
) -> anyhow::Result<()> {
    // Skip consistency check for first round (no previous folded codewords exist)
    if round > 0 {
        for (query, &folded_codeword, codeword_pair) in
            multizip((queries, folded_codewords, codewords))
        {
            if codeword_pair.len() != 2 {
                bail!("Codeword is not of correct length");
            }
            let (left, right) = (codeword_pair[0], codeword_pair[1]);
            check_fold(folded_codeword, *query, query_range, left, right)?;
            update_query(query, query_range);
        }
    }
    Ok(())
}

/// Verifies Merkle authentication paths for all queried codeword pairs.
///
/// Ensures that the prover provided authentic codewords from the committed
/// Reed-Solomon encoding, preventing substitution attacks.
pub fn verify_paths_vec<F>(
    codewords: &[Vec<F>],
    paths: &[MerklePath],
    queries: &[usize],
    oracle_commitment: [u8; 32],
) -> anyhow::Result<()>
where
    F: ExtensionField<Fp> + RawDataSerializable,
    Fp4: From<F>,
{
    for (query, path, codewords) in multizip((queries, paths, codewords)) {
        // if codewords.len() != 2 {
        //     bail!("Incorrect codeword length");
        // }
        let leaf_hash = blake3::hash(
            &F::into_byte_stream(codewords.clone())
                .into_iter()
                .collect::<Vec<_>>(),
        )
        .into();
        MerkleTree::verify_path(leaf_hash, *query, path, oracle_commitment)?;
    }
    Ok(())
}

/// Verifies consistency between folded codewords across rounds.
///
/// Checks that the current round's codeword pairs correctly fold to match
/// the previous round's folded results, preventing encoding manipulation.
pub fn check_query_consistency_dif(
    queries: &mut [usize],
    folded_codewords: &[Fp4],
    codewords: &[(Fp4, Fp4)],
    query_range: usize,
    round: usize,
) -> anyhow::Result<()> {
    // Skip consistency check for first round (no previous folded codewords exist)
    if round > 0 {
        for (query, &folded_codeword, &codeword_pair) in
            multizip((queries, folded_codewords, codewords))
        {
            let (left, right) = codeword_pair;
            check_fold_dif(folded_codeword, *query, query_range, left, right)?;
            update_query_dif(query, query_range);
        }
    }
    Ok(())
}

/// Verifies a single sum-check round during the verification phase.
///
/// This function checks the consistency of one round's sum-check polynomial against
/// the current claim and updates the claim for the next round.
///
/// # Verification Process
/// 1. **Consistency Check**: Verify g(0) + g(1) = current_claim via evaluation point
/// 2. **Fiat-Shamir**: Observe polynomial coefficients to maintain transcript consistency
/// 3. **Claim Update**: Set new claim = g(challenge) for next round
///
/// # Parameters
/// * `round_poly` - The sum-check univariate polynomial g(X) for this round
/// * `current_claim` - The current sum-check claim (updated in-place)
/// * `eval_point_round` - The evaluation point component for this round
/// * `challenger` - Fiat-Shamir challenger for transcript consistency
///
/// # Mathematical Verification
/// The function asserts that:
/// ```text
/// current_claim = (1 - eval_point_round) * g(0) + eval_point_round * g(1)
/// ```
/// This ensures the sum-check reduction is performed correctly.
///
/// # Returns
/// * `Ok(())` - If sum-check verification passes
/// * `Err(anyhow::Error)` - If consistency equation is violated
pub fn verify_sum_check_round(
    round_poly: &UnivariatePoly,
    current_claim: &mut Fp4,
    eval_point: &[Fp4],
    round: usize,
) -> anyhow::Result<()> {
    let expected = (Fp4::ONE - eval_point[round]) * round_poly.evaluate(Fp4::ZERO)
        + eval_point[round] * round_poly.evaluate(Fp4::ONE);

    if *current_claim != expected {
        anyhow::bail!(
            "Sum-check verification failed in round {round}: claim {:?} != expected {:?}",
            *current_claim,
            expected
        );
    }
    Ok(())
}

/// Updates a single query using bitwise masking optimization.
/// For power-of-2 halfsize: query &= (halfsize - 1) is equivalent to
/// the conditional subtraction but faster as it's a single bitwise operation.
pub fn update_query(query: &mut usize, halfsize: usize) {
    debug_assert!(halfsize.is_power_of_two(), "halfsize must be a power of 2");
    // Bitwise optimization: query &= (halfsize-1) equivalent to query %= halfsize
    // but faster for power-of-2 values
    *query &= halfsize - 1;
}

/// Updates a single query using bitwise masking optimization.
/// For power-of-2 halfsize: query &= (halfsize - 1) is equivalent to
/// the conditional subtraction but faster as it's a single bitwise operation.
pub fn update_query_dif(query: &mut usize, halfsize: usize) {
    debug_assert!(halfsize.is_power_of_two(), "halfsize must be a power of 2");
    // Bitwise optimization: query &= (halfsize-1) equivalent to query %= halfsize
    // but faster for power-of-2 values
    *query >>= 1;
}

/// Verifies the consistency of folding operations during query verification.
///
/// This function ensures that the current round's codewords correctly fold to match
/// the previous round's folded codewords, maintaining the integrity of the folding process.
///
/// # Folding Verification Process
/// For each query position, check that:
/// - If query index > halfsize: folded_codeword should equal the right codeword
/// - If query index ≤ halfsize: folded_codeword should equal the left codeword
///
/// This verification ensures the prover performed folding correctly and didn't manipulate
/// the encodings between rounds.
///
/// # Parameters
/// * `folded_codewords` - Previously computed folded codewords from last round
/// * `queries` - Query positions for the current verification round
/// * `query` - Index of current query being checked
/// * `halfsize` - Half the size of current encoding (for indexing logic)
/// * `left` - Left codeword from current query response
/// * `right` - Right codeword from current query response
///
/// # Returns
/// * `Ok(())` - If folding consistency check passes
/// * `Err(anyhow::Error)` - If folded codeword doesn't match expected value
///
/// # Security Properties
/// This check prevents the prover from providing inconsistent encodings across folding rounds,
/// which would allow them to cheat by using different polynomials in different rounds.
/// The verification leverages the deterministic nature of the folding operation.
/// Verifies the consistency of folding operations during query verification.
/// Uses bitwise operations for power-of-2 halfsize optimization.
pub fn check_fold(
    folded_codeword: Fp4,
    query: usize,
    halfsize: usize,
    left: Fp4,
    right: Fp4,
) -> anyhow::Result<()> {
    debug_assert!(halfsize.is_power_of_two(), "halfsize must be a power of 2");

    // Bitwise optimization: For power-of-2 halfsize, (query & halfsize) != 0
    // is equivalent to query >= halfsize but uses single bitwise operation
    if (query & halfsize) != 0 {
        if folded_codeword != right {
            anyhow::bail!(
                "Folded codeword verification failed: expected {:?}, got {:?}",
                (left, right),
                folded_codeword
            );
        }
    } else if folded_codeword != left {
        anyhow::bail!(
            "Folded codeword verification failed: expected {:?}, got {:?}",
            (left, right),
            folded_codeword
        );
    }

    Ok(())
}

pub fn check_fold_dif(
    folded_codeword: Fp4,
    query: usize,
    halfsize: usize,
    left: Fp4,
    right: Fp4,
) -> anyhow::Result<()> {
    debug_assert!(halfsize.is_power_of_two(), "halfsize must be a power of 2");

    // Bitwise optimization: For power-of-2 halfsize, (query & halfsize) != 0
    // is equivalent to query >= halfsize but uses single bitwise operation
    if (query & 1) != 0 {
        if folded_codeword != right {
            anyhow::bail!(
                "Folded codeword verification failed: expected {:?}, got {:?}",
                (left, right),
                folded_codeword
            );
        }
    } else if folded_codeword != left {
        anyhow::bail!(
            "Folded codeword verification failed: expected {:?}, got {:?}",
            (left, right),
            folded_codeword
        );
    }

    Ok(())
}
