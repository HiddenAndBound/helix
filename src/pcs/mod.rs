use std::f32::consts::E;
use std::iter::zip;
use std::ops::{Add, Div, Mul};
use std::sync::mpsc::channel;
use std::{slice, vec};

use anyhow::Ok;
use itertools::Itertools;
use p3_baby_bear::BabyBear;
use p3_field::{
    ExtensionField, Field, PrimeCharacteristicRing, PrimeField, PrimeField32, RawDataSerializable,
    TwoAdicField,
};
use p3_monty_31::BinomialExtensionData;

use crate::pcs::utils::{
    Commitment, Encoding, create_hash_leaves_from_pairs, create_hash_leaves_from_pairs_ref,
    encode_mle, fold, fold_pair, get_codewords, get_merkle_paths, hash_field_pair,
};
use crate::{
    Fp, Fp4,
    challenger::Challenger,
    commitment::PolynomialCommitment,
    eq::EqEvals,
    merkle_tree::{MerklePath, MerkleTree},
    polynomial::MLE,
    spartan::univariate::UnivariatePoly,
};

mod utils;
pub struct Basefold;

pub const QUERIES: usize = 144;

//TODO: Hash pruning, hash leaves together, oracle skipping, early stopping, rate_customisation.
/// Represents the commitment generated by the Basefold scheme, which is the Merkle root.
pub struct BasefoldCommitment {
    pub commitment: Commitment,
}

/// Holds the prover-specific data required for generating evaluation proofs.
pub struct ProverData {
    /// The Merkle tree built over the encoded polynomial.
    pub merkle_tree: MerkleTree,
    /// The encoded polynomial.
    pub encoding: Encoding,
}

pub struct EvalProof {
    pub sum_check_rounds: Vec<UnivariatePoly>,
    pub paths: Vec<Vec<MerklePath>>,
    pub commitments: Vec<Commitment>,
    pub codewords: Vec<Vec<(Fp4, Fp4)>>,
}

impl Basefold {
    pub fn commit(poly: &MLE<Fp>, roots: Vec<Vec<Fp>>) -> (BasefoldCommitment, ProverData) {
        assert!(
            poly.len().is_power_of_two(),
            "MLE's coefficients need to be a power of 2"
        );

        let encoding = encode_mle(poly, &roots);

        let (left, right) = encoding.split_at(encoding.len() / 2);
        let leaves: Vec<[u8; 32]> = create_hash_leaves_from_pairs(left, right);

        let merkle_tree = MerkleTree::from_hash(&leaves).unwrap();
        let commitment = merkle_tree.root();

        (
            BasefoldCommitment { commitment },
            ProverData {
                merkle_tree,
                encoding,
            },
        )
    }

    pub fn evaluate(
        poly: &MLE<Fp>,
        eval_point: &[Fp4],
        challenger: &mut Challenger,
        evaluation: Fp4,
        prover_data: ProverData,
        roots: Vec<Vec<Fp>>,
    ) -> Result<EvalProof, anyhow::Error> {
        assert_eq!(
            poly.n_vars(),
            eval_point.len(),
            "MLE's variables and point's coordinates must match."
        );

        let (
            mut current_claim,
            mut random_point,
            mut sum_check_rounds,
            mut commitments,
            mut merkle_trees,
            mut encodings,
            mut current_poly,
        ) = Self::initialize_evaluation_proof_context(evaluation, poly.n_vars());

        let eq = EqEvals::gen_from_point(&eval_point[1..]);
        let rounds = poly.n_vars();

        //Commit phase
        for round in 0..rounds {
            let (round_proof, r) = match round {
                0 => Self::process_sum_check_round(
                    poly,
                    &eval_point,
                    &mut current_claim,
                    challenger,
                    round,
                    &eq,
                ),
                _ => Self::process_sum_check_round(
                    &current_poly,
                    &eval_point,
                    &mut current_claim,
                    challenger,
                    round,
                    &eq,
                ),
            };

            let (current_encoding, current_poly_folded) = Self::fold_encoding_and_polynomial(
                round,
                &prover_data.encoding,
                &encodings,
                r,
                &roots,
                poly,
                &current_poly,
            );
            current_poly = current_poly_folded;

            Self::update_merkle_and_commitments_for_round(
                current_encoding,
                &mut commitments,
                &mut merkle_trees,
                &mut encodings,
            )?;

            challenger.observe_commitment(
                commitments
                    .last()
                    .expect("Will be non-empty after at least 1 fold"),
            );
            current_claim = round_proof.evaluate(r);

            sum_check_rounds.push(round_proof);
            random_point.push(r);
        }

        //Query phase
        let mut queries = challenger.get_indices(rounds as u32, QUERIES);

        let mut codewords = Vec::new();
        let mut paths = Vec::new();
        for round in 0..rounds {
            let round_codewords: Vec<(Fp4, Fp4)> = match round {
                0 => get_codewords(&queries, &prover_data.encoding),
                _ => get_codewords(&queries, &encodings[round - 1]),
            };
            codewords.push(round_codewords);

            let round_paths: Vec<MerklePath> = match round {
                0 => get_merkle_paths(&queries, &prover_data.merkle_tree),
                _ => get_merkle_paths(&queries, &merkle_trees[round - 1]),
            };
            paths.push(round_paths);

            queries.iter_mut().for_each(|query| *query >>= 1);
        }

        Ok(EvalProof {
            sum_check_rounds,
            paths,
            commitments,
            codewords,
        })
    }

    fn process_sum_check_round<F>(
        poly: &MLE<F>,
        eval_point: &[Fp4],
        current_claim: &mut Fp4,
        challenger: &mut Challenger,
        round: usize,
        eq: &EqEvals,
    ) -> (UnivariatePoly, Fp4)
    where
        F: PrimeCharacteristicRing + Field,
        Fp4: ExtensionField<F>,
    {
        let mut g_0: Fp4 = Fp4::ZERO;

        for i in 0..1 << (poly.n_vars() - round - 1) {
            g_0 += eq[i] * poly[i << 1]
        }

        let g1: Fp4 = (*current_claim - g_0 * (Fp4::ONE - eval_point[round])) / eval_point[0];

        let round_coeffs = vec![g_0, g1 - g_0];
        let round_proof = UnivariatePoly::new(round_coeffs).unwrap();

        challenger.observe_fp4_elems(&round_proof.coefficients());

        let r = challenger.get_challenge();
        (round_proof, r)
    }

    fn fold_encoding_and_polynomial(
        round: usize,
        initial_encoding: &Encoding,
        encodings: &[Vec<Fp4>],
        r: Fp4,
        roots: &[Vec<Fp>],
        initial_poly: &MLE<Fp>,
        current_poly: &MLE<Fp4>,
    ) -> (Vec<Fp4>, MLE<Fp4>) {
        let current_encoding = match round {
            0 => fold(initial_encoding, r, &roots[round]),
            _ => fold(
                encodings.last().expect("Will be non-empty"),
                r,
                &roots[round],
            ),
        };

        let current_poly_folded = match round {
            0 => initial_poly.fold_in_place(r),
            _ => current_poly.fold_in_place(r),
        };
        (current_encoding, current_poly_folded)
    }

    fn initialize_evaluation_proof_context(
        evaluation: Fp4,
        rounds: usize,
    ) -> (
        Fp4,
        Vec<Fp4>,
        Vec<UnivariatePoly>,
        Vec<Commitment>,
        Vec<MerkleTree>,
        Vec<Vec<Fp4>>,
        MLE<Fp4>,
    ) {
        let current_claim = evaluation;
        let random_point = Vec::new();
        let round_proofs = Vec::new();
        let commitments = Vec::new();
        let merkle_trees = Vec::new();
        let encodings = Vec::<Vec<Fp4>>::new();
        let current_poly = MLE::default();
        (
            current_claim,
            random_point,
            round_proofs,
            commitments,
            merkle_trees,
            encodings,
            current_poly,
        )
    }

    fn update_merkle_and_commitments_for_round(
        current_encoding: Vec<Fp4>,
        commitments: &mut Vec<Commitment>,
        merkle_trees: &mut Vec<MerkleTree>,
        encodings: &mut Vec<Vec<Fp4>>,
    ) -> Result<(), anyhow::Error> {
        let (left, right) = current_encoding.split_at(current_encoding.len() / 2);

        let leaves: Vec<[u8; 32]> = create_hash_leaves_from_pairs_ref(left, right);
        let current_merkle_tree = MerkleTree::from_field(&current_encoding)?;
        let current_commitment = current_merkle_tree.root();

        commitments.push(current_commitment);
        merkle_trees.push(current_merkle_tree);
        encodings.push(current_encoding);
        Ok(())
    }

    pub fn verify(
        proof: EvalProof,
        evaluation: Fp4,
        eval_point: &[Fp4],
        commitment: BasefoldCommitment,
        roots: &Vec<Vec<Fp>>,
        challenger: &mut Challenger,
    ) -> Result<(), anyhow::Error> {
        // TODO: Observe statement (eval, eval_point, commitment)
        let mut current_claim = evaluation;

        let rounds = eval_point.len();

        let mut random_point = Vec::new();
        //Commit phase
        for round in 0..rounds {
            Self::verify_sum_check_round(
                &proof.sum_check_rounds[round],
                &mut current_claim,
                eval_point[round],
                challenger,
            );
            random_point.push(challenger.get_challenge()); // Get the challenge 'r' after observing coefficients
            challenger.observe_commitment(&proof.commitments[round]);
        }

        let queries = challenger.get_indices(rounds as u32, QUERIES);

        let mut current_codewords = &proof.codewords[0];
        let mut folded_codewords = Vec::new();
        let mut merkle_paths = &proof.paths[0];
        for round in 0..rounds - 1 {
            let halfsize = 1 << (rounds - round - 1);

            for query in 0..QUERIES {
                let (left, right) = current_codewords[query];
                let leaf_hash = hash_field_pair(left, right);
                let path = &merkle_paths[query];
                match round {
                    0 => {
                        MerkleTree::verify_path(
                            leaf_hash,
                            queries[query],
                            path,
                            commitment.commitment,
                        )?;

                        folded_codewords.push(fold_pair(
                            current_codewords[query],
                            random_point[round],
                            roots[round][query & (1 << (rounds - round - 1)) - 1],
                        ));
                    }
                    _ => {
                        MerkleTree::verify_path(
                            leaf_hash,
                            queries[query],
                            path,
                            proof.commitments[round - 1],
                        )?;
                        check_fold(&folded_codewords, &queries, query, halfsize, left, right)?;
                        folded_codewords[query] = fold_pair(
                            current_codewords[query],
                            random_point[round],
                            roots[round][query & (1 << (rounds - round - 1)) - 1],
                        );
                    }
                }
            }

            current_codewords = &proof.codewords[round + 1];
            merkle_paths = &proof.paths[round + 1];
        }

        if folded_codewords[0] != current_claim {
            return Err(anyhow::anyhow!(
                "Final folded codeword does not match current claim"
            ));
        }
        Ok(())
    }

    fn verify_sum_check_round(
        round_poly: &UnivariatePoly,
        current_claim: &mut Fp4,
        eval_point_round: Fp4,
        challenger: &mut Challenger,
    ) {
        assert_eq!(
            *current_claim,
            (Fp4::ONE - eval_point_round) * round_poly.evaluate(Fp4::ZERO)
                + eval_point_round * round_poly.evaluate(Fp4::ONE)
        );

        challenger.observe_fp4_elems(&round_poly.coefficients());
        *current_claim = round_poly.evaluate(challenger.get_challenge());
    }
}

fn check_fold(
    folded_codewords: &[Fp4],
    queries: &[usize],
    query: usize,
    halfsize: usize,
    left: Fp4,
    right: Fp4,
) -> Result<(), anyhow::Error> {
    if queries[query] > halfsize {
        if folded_codewords[query] != right {
            return Err(anyhow::anyhow!("Folded codeword does not match right"));
        }
    } else {
        if folded_codewords[query] != left {
            return Err(anyhow::anyhow!("Folded codeword does not match left"));
        }
    }

    Ok(())
}
