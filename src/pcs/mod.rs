use std::ops::{Add, Div, Mul};
use std::sync::mpsc::channel;
use std::vec;

use anyhow::Ok;
use p3_baby_bear::BabyBear;
use p3_field::{
    ExtensionField, Field, PrimeCharacteristicRing, PrimeField, PrimeField32, TwoAdicField,
};
use p3_monty_31::BinomialExtensionData;

use crate::{
    Fp, Fp4,
    challenger::Challenger,
    commitment::PolynomialCommitment,
    eq::EqEvals,
    merkle_tree::{MerklePath, MerkleTree},
    polynomial::MLE,
    spartan::univariate::UnivariatePoly,
};

pub struct Basefold;

pub type Commitment = [u8; 32];
pub type Encoding = Vec<Fp>;

const QUERIES: usize = 144;
//TODO: Hash pruning, hash leaves together, oracle skipping.
/// Represents the commitment generated by the Basefold scheme, which is the Merkle root.
pub struct BasefoldCommitment {
    pub commitment: Commitment,
}

/// Holds the prover-specific data required for generating evaluation proofs.
pub struct ProverData {
    /// The Merkle tree built over the encoded polynomial.
    pub merkle_tree: MerkleTree,
    /// The encoded polynomial.
    pub encoding: Encoding,
}

const RATE: usize = 2;
const HALF: Fp = Fp::new(134217727);

pub struct EvalProof {
    pub sum_check_rounds: Vec<UnivariatePoly>,
    pub paths: Vec<Vec<MerklePath>>,
    pub commitments: Vec<Commitment>,
    pub codewords: Vec<Vec<(Fp4, Fp4)>>,
}

impl Basefold {
    pub fn commit(poly: &MLE<Fp>, roots: Vec<Vec<Fp>>) -> (BasefoldCommitment, ProverData) {
        assert!(
            poly.len().is_power_of_two(),
            "MLE's coefficients need to be a power of 2"
        );

        let encoding = encode_mle(poly, &roots);

        let merkle_tree = MerkleTree::from_field(&encoding).unwrap();
        let commitment = merkle_tree.root();

        (
            BasefoldCommitment { commitment },
            ProverData {
                merkle_tree,
                encoding,
            },
        )
    }

    pub fn evaluate(
        poly: &MLE<Fp>,
        eval_point: &[Fp4],
        challenger: &mut Challenger,
        evaluation: Fp4,
        prover_data: ProverData,
        roots: Vec<Vec<Fp>>,
    ) -> Result<EvalProof, anyhow::Error> {
        assert_eq!(
            poly.n_vars(),
            eval_point.len(),
            "MLE's variables and point's coordinates must match."
        );

        let (
            mut current_claim,
            mut random_point,
            mut sum_check_rounds,
            mut commitments,
            mut merkle_trees,
            mut encodings,
            mut current_poly,
        ) = Self::initialize_evaluation_proof_context(evaluation, poly.n_vars());

        let eq = EqEvals::gen_from_point(&eval_point[1..]);
        let rounds = poly.n_vars();

        //Commit phase
        for round in 0..rounds {
            let (round_proof, r) = match round {
                0 => Self::process_sum_check_round(
                    poly,
                    &eval_point,
                    &mut current_claim,
                    challenger,
                    round,
                    &eq,
                ),
                _ => Self::process_sum_check_round(
                    &current_poly,
                    &eval_point,
                    &mut current_claim,
                    challenger,
                    round,
                    &eq,
                ),
            };

            let (current_encoding, current_poly_folded) = Self::fold_encoding_and_polynomial(
                round,
                &prover_data.encoding,
                &encodings,
                r,
                &roots,
                poly,
                &current_poly,
            );
            current_poly = current_poly_folded;

            Self::update_merkle_and_commitments_for_round(
                current_encoding,
                &mut commitments,
                &mut merkle_trees,
                &mut encodings,
            )?;

            challenger.observe_commitment(
                commitments
                    .last()
                    .expect("Will be non-empty after at least 1 fold"),
            );
            current_claim = round_proof.evaluate(r);

            sum_check_rounds.push(round_proof);
            random_point.push(r);
        }

        //Query phase

        let mut queries = challenger.get_indices(rounds as u32, QUERIES);

        let mut codewords = Vec::new();
        let mut paths = Vec::new();
        for round in 0..rounds {
            let round_codewords: Vec<(Fp4, Fp4)> = match round {
                0 => get_codewords(&queries, &prover_data.encoding),
                _ => get_codewords(&queries, &encodings[round - 1]),
            };
            codewords.push(round_codewords);

            let round_paths: Vec<MerklePath> = match round {
                0 => get_merkle_paths(&queries, &prover_data.merkle_tree),
                _ => get_merkle_paths(&queries, &merkle_trees[round - 1]),
            };
            paths.push(round_paths);

            queries.iter_mut().for_each(|query| *query >>= 1);
        }

        Ok(EvalProof {
            sum_check_rounds,
            paths,
            commitments: todo!(),
            codewords: todo!(),
        })
    }

    fn process_sum_check_round<F>(
        poly: &MLE<F>,
        eval_point: &[Fp4],
        current_claim: &mut Fp4,
        challenger: &mut Challenger,
        round: usize,
        eq: &EqEvals,
    ) -> (UnivariatePoly, Fp4)
    where
        F: PrimeCharacteristicRing + Field,
        Fp4: ExtensionField<F>,
    {
        let mut g_0: Fp4 = Fp4::ZERO;

        for i in 0..1 << (poly.n_vars() - round - 1) {
            g_0 += eq[i] * poly[i << 1]
        }

        let g1: Fp4 = (*current_claim - g_0 * (Fp4::ONE - eval_point[round])) / eval_point[0];

        let round_coeffs = vec![g_0, g1 - g_0];
        let round_proof = UnivariatePoly::new(round_coeffs).unwrap();

        challenger.observe_fp4_elems(&round_proof.coefficients());

        let r = challenger.get_challenge();
        (round_proof, r)
    }

    fn fold_encoding_and_polynomial(
        round: usize,
        initial_encoding: &Encoding,
        encodings: &[Vec<Fp4>],
        r: Fp4,
        roots: &[Vec<Fp>],
        initial_poly: &MLE<Fp>,
        current_poly: &MLE<Fp4>,
    ) -> (Vec<Fp4>, MLE<Fp4>) {
        let current_encoding = match round {
            0 => fold(initial_encoding, r, &roots[round]),
            _ => fold(
                encodings.last().expect("Will be non-empty"),
                r,
                &roots[round],
            ),
        };

        let current_poly_folded = match round {
            0 => initial_poly.fold_in_place(r),
            _ => current_poly.fold_in_place(r),
        };
        (current_encoding, current_poly_folded)
    }

    fn initialize_evaluation_proof_context(
        evaluation: Fp4,
        rounds: usize,
    ) -> (
        Fp4,
        Vec<Fp4>,
        Vec<UnivariatePoly>,
        Vec<Commitment>,
        Vec<MerkleTree>,
        Vec<Vec<Fp4>>,
        MLE<Fp4>,
    ) {
        let current_claim = evaluation;
        let random_point = Vec::new();
        let round_proofs = Vec::new();
        let commitments = Vec::new();
        let merkle_trees = Vec::new();
        let encodings = Vec::<Vec<Fp4>>::new();
        let current_poly = MLE::default();
        (
            current_claim,
            random_point,
            round_proofs,
            commitments,
            merkle_trees,
            encodings,
            current_poly,
        )
    }

    fn update_merkle_and_commitments_for_round(
        current_encoding: Vec<Fp4>,
        commitments: &mut Vec<Commitment>,
        merkle_trees: &mut Vec<MerkleTree>,
        encodings: &mut Vec<Vec<Fp4>>,
    ) -> Result<(), anyhow::Error> {
        let current_merkle_tree = MerkleTree::from_field(&current_encoding)?;
        let current_commitment = current_merkle_tree.root();

        commitments.push(current_commitment);
        merkle_trees.push(current_merkle_tree);
        encodings.push(current_encoding);
        Ok(())
    }

    pub fn verify(
        proof: EvalProof,
        evaluation: Fp4,
        eval_point: &[Fp4],
        commitment: BasefoldCommitment,
        challenger: &mut Challenger,
    ) {
        let mut current_claim = evaluation;

        let rounds = eval_point.len();

        let mut random_point = Vec::new();
        for round in 0..rounds {
            Self::verify_sum_check_round(
                &proof.sum_check_rounds[round],
                &mut current_claim,
                eval_point[round],
                challenger,
            );
            random_point.push(challenger.get_challenge()); // Get the challenge 'r' after observing coefficients
        }
    }

    fn verify_sum_check_round(
        round_poly: &UnivariatePoly,
        current_claim: &mut Fp4,
        eval_point_round: Fp4,
        challenger: &mut Challenger,
    ) {
        assert_eq!(
            *current_claim,
            (Fp4::ONE - eval_point_round) * round_poly.evaluate(Fp4::ZERO)
                + eval_point_round * round_poly.evaluate(Fp4::ONE)
        );

        challenger.observe_fp4_elems(&round_poly.coefficients());
        *current_claim = round_poly.evaluate(challenger.get_challenge());
    }
}

fn encode_mle(poly: &MLE<Fp>, roots: &[Vec<Fp>]) -> Encoding {
    let mut buffer = vec![Fp::ZERO; poly.len() * RATE];
    buffer[0..poly.len()].copy_from_slice(poly.coeffs());

    assert!(
        roots.len() > buffer.len().trailing_zeros() as usize,
        "Root table not large enough to encode the MLE."
    );

    BabyBear::forward_fft(&mut buffer, roots);
    buffer
}

pub fn fold_pair<F>(codewords: (F, F), r: Fp4, twiddle: Fp) -> Fp4
where
    F: Field + Mul<Fp, Output = F>,
    Fp4: ExtensionField<F>,
{
    let (a0, a1) = codewords;
    let (g0, g1) = ((a0 - a1) * HALF, (a0 + a1) * HALF * twiddle);
    r * (g0 + g1) + g0
}

pub fn fold<F>(mle: &[F], random_challenge: Fp4, roots: &[Fp]) -> Vec<Fp4>
where
    F: Field + Mul<Fp, Output = F>,
    Fp4: ExtensionField<F>,
{
    let half_size = mle.len() >> 1;
    let mut folded = vec![Fp4::ZERO; half_size];
    for i in 0..half_size {
        folded[i] = fold_pair((mle[i], mle[i + half_size]), random_challenge, roots[i])
    }

    folded
}

fn get_codewords<F: Into<Fp4> + Copy>(queries: &[usize], encoding: &[F]) -> Vec<(Fp4, Fp4)> {
    let halfsize = encoding.len() / 2;
    queries
        .iter()
        .copied()
        .map(|i| {
            if i > halfsize {
                (encoding[i ^ halfsize].into(), encoding[i].into())
            } else {
                (encoding[i].into(), encoding[i ^ halfsize].into())
            }
        })
        .collect()
}

//We assume that codewords to be folded are hashed together.
fn get_merkle_paths(queries: &[usize], merkle_tree: &MerkleTree) -> Vec<MerklePath> {
    let halfsize = 1 << merkle_tree.depth;
    queries
        .iter()
        .copied()
        .map(|i| {
            // As pairs that differ in their most dominant bit are hashed together, we only index leaf nodes by the trailing bits.
            // Thus in the case an index is above the halfsize, meaning its leading bit is 1, we toggle that bit to get the valid and appropriate index.
            if i > halfsize {
                merkle_tree.get_path(i ^ halfsize)
            } else {
                merkle_tree.get_path(i)
            }
        })
        .collect()
}
